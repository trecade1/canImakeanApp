canImakeanApp â€” Architecture

Recommended Stack (MVP)
- Backend: Node.js + Express (fast iteration) or Supabase (if you want hosted Postgres + auth).
- Database: PostgreSQL
- Mobile app: React Native (Android + iOS) using `react-native-nfc-manager` for NFC read/write.
- Frontend (optional): React for profile/feed viewing.
- Hosting: Railway/Heroku/Supabase for backend; Vercel for any web frontend.

High-level Components
- Mobile App: handles auth, NFC write/read for pairing, creating posts, and rendering feed.
- Backend API: authentication, pairing-code issuance, pairing claim validation, posts, feed query, and pairings management.
- Database: stores users, issued tokens/codes, pairings, posts, and revocations.

Data Flow (pairing)
1. Owner requests pairing code (POST `/pairing/request-code`).
2. Backend issues a signed one-time payload with TTL and returns it to owner.
3. Owner writes payload to NFC tag.
4. Recipient reads tag and POSTs payload to `/pairing/claim` (authenticated).
5. Backend validates signature, TTL, and one-time use; creates `pairings` record linking both users.

Feed Generation
- Each user's feed is generated by querying posts whose `author_id` appears in the user's pairing list.
- Query: SELECT * FROM posts WHERE author_id IN (SELECT other_id FROM pairings WHERE user = current_user) ORDER BY created_at DESC

Scalability Notes
- Pairings are symmetric; can be stored as a single row per pair with indexes for fast lookups.
- For large scale, denormalize pairing memberships into a membership table or use precomputed timelines.
- Use Redis for caching hot feeds and rate-limiting pairing code issuance.
